WEBVTT
Kind: captions
Language: zh-CN

00:00:00.540 --> 00:00:03.690
Katie 你告诉大家关于训练和测试集的内容

00:00:03.690 --> 00:00:06.700
我希望大家也做了一些练习

00:00:06.700 --> 00:00:08.510
— 是的吗？ — 是的

00:00:08.510 --> 00:00:11.900
现在我要讨论的内容是将其稍微推广了一下 

00:00:11.900 --> 00:00:13.790
叫做交叉验证

00:00:13.790 --> 00:00:17.360
在进入交叉验证之前 我们先来讨论一下

00:00:17.360 --> 00:00:20.950
将数据集分拆为训练和测试数据的问题

00:00:20.950 --> 00:00:22.580
假设这就是你的数据

00:00:22.580 --> 00:00:25.000
用 Katie 教你的方法来做

00:00:25.000 --> 00:00:29.330
现在你要说出哪个部分的数据是测试 哪个是训练

00:00:29.330 --> 00:00:33.710
你进入的困境是希望将两个集合都做到最大化

00:00:33.710 --> 00:00:36.458
你希望在训练集中有尽可能多的数据点

00:00:36.458 --> 00:00:40.241
以获得最佳学习结果 同时也希望测试集中有最大数量的数据项

00:00:40.241 --> 00:00:42.500
来获得最佳验证

00:00:42.500 --> 00:00:46.230
但显然这里需要进行折衷 每当你从训练集中取出一个数据点拿去测试

00:00:46.230 --> 00:00:50.180
训练集中就会少一个数据点

00:00:50.180 --> 00:00:52.070
所以 我们要重新设定这个折衷

00:00:52.070 --> 00:00:54.950
这就是涉及到交叉验证的地方

00:00:54.950 --> 00:01:01.540
基本要点是将训练数据平分到相同大小的 k 个容器内

00:01:01.540 --> 00:01:04.700
例如有 200 个训练数据点

00:01:04.700 --> 00:01:06.580
有十个容器

00:01:06.580 --> 00:01:07.430
很快便可得出

00:01:07.430 --> 00:01:09.003
每个容器内有多少个数据点呢？

00:01:09.003 --> 00:01:10.391
很明显 是 20

00:01:10.391 --> 00:01:14.490
所以 10 个容器内分别有 20 个数据点

00:01:14.490 --> 00:01:15.630
就是这样

00:01:15.630 --> 00:01:19.946
然而在 Katie 讲述的操作中 你只是挑选其中一个容器

00:01:19.946 --> 00:01:22.454
作为验证容器 另一个作为训练容器

00:01:22.454 --> 00:01:27.550
在 k 折交叉验证中 你将运行 k 次单独的学习试验

00:01:27.550 --> 00:01:32.380
在每次试验中 你将从这 k 个子集中挑选一个作为验证集

00:01:32.380 --> 00:01:36.336
剩下 k-1 个容器放在一起作为训练集

00:01:36.336 --> 00:01:39.153
然后训练你的机器学习算法

00:01:39.153 --> 00:01:43.370
与以前一样 将在验证集上验证性能

00:01:43.370 --> 00:01:46.710
交叉验证中的要点是这个操作会运行多次

00:01:46.710 --> 00:01:51.310
在此例中为十次 然后将十个不同的测试集

00:01:51.310 --> 00:01:53.731
对于十个不同的保留集的表现进行平均

00:01:53.731 --> 00:01:57.460
就是将这 k 次试验的测试结果取平均值

00:01:57.460 --> 00:02:00.430
显然 这会花更多的计算时间 因为你要运行

00:02:00.430 --> 00:02:02.700
k 次单独的学习试验

00:02:02.700 --> 00:02:05.940
但学习算法的评估将更加准确

00:02:05.940 --> 00:02:08.240
从某种程度上讲 你差不多使用了全部训练数据进行训练

00:02:08.240 --> 00:02:11.820
以及全部训练数据进行验证 很酷

00:02:11.820 --> 00:02:13.320
比如我们提一个问题

00:02:13.320 --> 00:02:17.060
假设你可以选择按照 Katie 讲述的静态训练测试方法来操作

00:02:17.060 --> 00:02:21.630
也可以按照 10 折交叉验证来操作

00:02:21.630 --> 00:02:24.070
你实际关心的是将训练时间降至最低

00:02:24.070 --> 00:02:27.700
使用机器学习算法进行训练后将运行时间降至最低

00:02:27.700 --> 00:02:30.870
忽略训练时间 将查准率提至最高

00:02:30.870 --> 00:02:34.438
在这三种情形下 你可以挑选训练/测试或者

00:02:34.438 --> 00:02:36.210
10 折交叉验证

00:02:36.210 --> 00:02:37.140
告诉我你的最佳猜测

00:02:37.140 --> 00:02:38.140
你会选择哪一种？

00:02:38.140 --> 00:02:39.760
对于每个最短的训练时间

00:02:39.760 --> 00:02:41.180
请在右边选择两者之一

