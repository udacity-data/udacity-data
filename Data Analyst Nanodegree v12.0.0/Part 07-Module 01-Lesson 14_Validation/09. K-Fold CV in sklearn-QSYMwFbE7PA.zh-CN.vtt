WEBVTT
Kind: captions
Language: zh-CN

00:00:00.180 --> 00:00:03.594
你已经对 K 折交叉验证背后的理论

00:00:03.594 --> 00:00:04.830
有所了解

00:00:04.830 --> 00:00:07.660
今天我们学习代码 这对你来说应该不困难

00:00:07.660 --> 00:00:12.030
K 折交叉验证可在 sklearn 中的

00:00:12.030 --> 00:00:14.300
交叉验证函数集中使用

00:00:14.300 --> 00:00:17.330
接下来 我将向你展示该功能部署后的样子

00:00:17.330 --> 00:00:20.030
这里的代码对你来说

00:00:20.030 --> 00:00:21.490
应该不陌生

00:00:21.490 --> 00:00:24.490
这些代码是我们在第一个微型项目中使用过的

00:00:24.490 --> 00:00:27.180
用来确认写电子邮件的人

00:00:27.180 --> 00:00:28.690
是 Sara 还是 Chris

00:00:29.990 --> 00:00:32.810
我使用的是高斯朴素贝叶斯

00:00:32.810 --> 00:00:36.040
我记录了此分类器的

00:00:36.040 --> 00:00:38.470
训练时间、预测时间以及准确性

00:00:39.720 --> 00:00:43.105
注意我使用的特征是电子邮件中的字词

00:00:43.105 --> 00:00:46.790
而我要达到的目的是 根据电子邮件中使用的词汇推测

00:00:46.790 --> 00:00:48.110
写电子邮件的人

00:00:48.110 --> 00:00:50.950
这上方是我进行的一些特征转换

00:00:50.950 --> 00:00:55.590
我首先读取文字的内容 然后进行特征选择

00:00:55.590 --> 00:00:56.890
以上是我们之前讲过的内容

00:00:56.890 --> 00:00:59.180
这里就不详述了

00:00:59.180 --> 00:01:01.390
这段代码更有意思

00:01:01.390 --> 00:01:06.220
首先我从 sklearn.cross_validation 中导入 KFold

00:01:06.220 --> 00:01:09.410
这是 sklearn 中 K 折交叉验证函数的名称

00:01:09.410 --> 00:01:14.640
然后我必须声明一个 K 折对象 该对象接受两个参数

00:01:14.640 --> 00:01:19.500
一个是数据总集中的项目数量

00:01:19.500 --> 00:01:20.820
在这个例子中

00:01:20.820 --> 00:01:23.450
该参数的值与数据集中的作者数相同

00:01:23.450 --> 00:01:26.850
另一个参数是我想查看多少个折

00:01:26.850 --> 00:01:28.840
在本例中 我选择了两个

00:01:28.840 --> 00:01:31.000
你可以更改这些内容

00:01:31.000 --> 00:01:35.260
KFold 函数的作用就是提供两个列表

00:01:35.260 --> 00:01:37.870
第一个列表是我要在训练集中使用的

00:01:37.870 --> 00:01:40.810
所有数据点的索引值的集合

00:01:40.810 --> 00:01:44.520
第二个列表包含我要在测试数据集中使用的

00:01:44.520 --> 00:01:45.680
所有索引值

00:01:45.680 --> 00:01:50.090
然后 我可以使用这些索引值进入特征和标签

00:01:50.090 --> 00:01:54.230
并将各个特征集或标签分配给

00:01:54.230 --> 00:01:57.250
训练或测试数据集

00:01:57.250 --> 00:02:00.848
这就是将数据划分到训练和测试数据集

00:02:00.848 --> 00:02:02.090
的实际操作

00:02:02.090 --> 00:02:04.210
下面的操作与之前类似

00:02:04.210 --> 00:02:07.870
我们对训练和测试数据进行一些转换

00:02:07.870 --> 00:02:10.750
然后训练分类器 并评估准确性

00:02:10.750 --> 00:02:13.330
如果我直接执行这一操作

00:02:13.330 --> 00:02:15.960
就有可能会出问题

00:02:15.960 --> 00:02:18.110
下面我来演示运行代码时会出现的情况

