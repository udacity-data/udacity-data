WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.120
好了 第一个编程评估是对病人表格中的姓和地址列

00:00:03.120 --> 00:00:06.265
运行 .value_counts

00:00:06.264 --> 00:00:08.744
value_counts 是一种直方图函数

00:00:08.744 --> 00:00:11.969
返回的是该列中某个特定值的计数

00:00:11.970 --> 00:00:17.995
这里有六个病人姓 Doe 以及六个地址在 123 Main Street

00:00:17.995 --> 00:00:22.365
我感觉这可能是因为重复 我们可以用 .duplicated 查看

00:00:22.364 --> 00:00:26.864
这样会返回我们可以用来索引病人的布尔数组

00:00:26.864 --> 00:00:31.799
是的 这里有很多位 John Doe

00:00:31.800 --> 00:00:34.215
都住在纽约 123 Main Street 邮编为12345

00:00:34.215 --> 00:00:36.180
还有很多的 johndoe@email.com

00:00:36.179 --> 00:00:39.009
这个明显是重复的默认数据

00:00:39.009 --> 00:00:40.504
这种情况是怎么发生的呢

00:00:40.505 --> 00:00:43.170
很有可能是因为一些系统更换

00:00:43.170 --> 00:00:46.440
比如说 如果公司的数据库

00:00:46.439 --> 00:00:51.479
从一个软件供应商转换至另外一个软件供应商 以进行病人记录

00:00:51.479 --> 00:00:53.339
在从一个系统更换至另一个系统的过程中

00:00:53.340 --> 00:00:59.250
可能会丢失一些数据 然后出现默认的 John Doe 数据或者甚至损坏数据

00:00:59.250 --> 00:01:01.185
医护数据中这个问题非常普遍

00:01:01.185 --> 00:01:03.539
因为大家都知道

00:01:03.539 --> 00:01:06.185
医护行业的技术向来都不是最新的

00:01:06.185 --> 00:01:09.295
那这个问题的合适的数据质量维度是什么呢？

00:01:09.295 --> 00:01:11.159
这个是有效性问题

00:01:11.159 --> 00:01:13.170
之前说过 有效性问题

00:01:13.170 --> 00:01:17.435
是指不符合预先确定的当前真实世界的情况

00:01:17.435 --> 00:01:19.799
六位 John Doe

00:01:19.799 --> 00:01:22.358
都住在纽约 123 Main Street

00:01:22.358 --> 00:01:26.339
使用同一个邮箱

00:01:26.340 --> 00:01:27.784
这真的是非常不可能的事情

00:01:27.784 --> 00:01:29.790
这种事情不可能存在

00:01:29.790 --> 00:01:33.135
虽然这个表格或数据库接受了这些记录

00:01:33.135 --> 00:01:35.890
但就真实世界的情况而言 这些记录是无效的

00:01:35.890 --> 00:01:40.013
John Doe 甚至可能都不存在 现实中很有可能是这样

00:01:40.013 --> 00:01:43.324
让我们记录下来

00:01:43.325 --> 00:01:49.540
这个问题必须要解决 因为我们不希望数据集中有垃圾数据

00:01:49.540 --> 00:01:53.035
也就是说 我们可能要移除这些记录 或者找到丢失的记录

00:01:53.034 --> 00:01:54.399
我们之后再来处理

00:01:54.400 --> 00:01:57.835
现在我们只进行评估 并写下自己的观察结果

00:01:57.834 --> 00:01:59.890
通过 duplicated 实际上我们还可以发现另外一个数据质量问题

00:01:59.890 --> 00:02:04.525
这个 Jake Jacobson 的记录有些问题

00:02:04.525 --> 00:02:07.120
你可以发现它的地址是重复的

00:02:07.120 --> 00:02:09.969
与这条记录

00:02:09.969 --> 00:02:12.724
或者下面两条显示 NaN 条目的记录不一样

00:02:12.724 --> 00:02:16.060
也就意味着病人表格中有两个人地址是相同的

00:02:16.060 --> 00:02:18.180
648 Old Dear Lane

00:02:18.180 --> 00:02:19.775
我记得之前我们在目测评估的时候

00:02:19.775 --> 00:02:23.145
看见过 Jacobson 我们向上滑动看看

00:02:23.145 --> 00:02:25.505
这里 Jacob Jacobson

00:02:25.504 --> 00:02:28.884
648 Old Dear Lane 然后还有一个 Jake Jacobson

00:02:28.884 --> 00:02:31.679
这就是我们在 duplicated 结果中看到的记录

00:02:31.680 --> 00:02:34.905
这看上去是一个人的两条记录

00:02:34.905 --> 00:02:39.235
之所以另外创建了一条记录和一个病人 ID 是因为使用了昵称

00:02:39.235 --> 00:02:43.000
应该是 Jake Jacobson 来过两次

00:02:43.000 --> 00:02:45.430
而负责创建病人记录的人又另外记录了一条 Jake 的信息

00:02:45.430 --> 00:02:48.140
因为没发现数据库中已经有他的信息了

00:02:48.139 --> 00:02:52.000
使用昵称重复创建记录是医护行业中

00:02:52.000 --> 00:02:54.189
非常常见的问题

00:02:54.189 --> 00:02:57.645
每一年医护公司和医院都要耗重金来解决这个问题

00:02:57.645 --> 00:02:59.230
如果你想了解更多内容

00:02:59.229 --> 00:03:01.280
可以查看视频下方说明中的链接

00:03:01.280 --> 00:03:04.245
所以这是一个有效性问题

00:03:04.245 --> 00:03:07.205
虽然很容易误以为它是一致性问题

00:03:07.205 --> 00:03:09.985
用两种方式称呼同一件事物

00:03:09.985 --> 00:03:11.705
Jake 和 Jacob Jacobson 这种一致性问题

00:03:11.705 --> 00:03:14.485
虽然它对于表格来说是有效的

00:03:14.485 --> 00:03:16.750
没有重复的病人 ID

00:03:16.750 --> 00:03:18.409
比如说 Jake Jacobson 的病人 ID 是 30

00:03:18.409 --> 00:03:20.949
Jacob 是 25

00:03:20.949 --> 00:03:24.329
但是就真实世界情况而言它是无效的

00:03:24.330 --> 00:03:27.435
因为没有两个人 他只是一个人

00:03:27.435 --> 00:03:30.620
病人表中出现了两条记录 而实际上只需要一条

00:03:30.620 --> 00:03:32.557
在删除其中一个复制内容时

00:03:32.557 --> 00:03:33.789
如果我们错误地删除了一条内容

00:03:33.789 --> 00:03:37.500
这样就会造成多个表格之间的一致性问题

00:03:37.500 --> 00:03:41.020
比如说 治疗表中是 Jacob Jacobson

00:03:41.020 --> 00:03:45.130
而病人表中只留下了 Jake Jacobson 我们删掉了 Jacob Jacobson

00:03:45.129 --> 00:03:48.519
这样就会造成各个表格之间的不一致问题

00:03:48.520 --> 00:03:51.850
但是每个人只留下了一条记录

00:03:51.849 --> 00:03:53.569
这样它是有效的 但却是不一致的

00:03:53.569 --> 00:03:55.319
但这不是我们眼下的问题

00:03:55.319 --> 00:03:57.459
现在我们是有两种方式找到两条记录

00:03:57.460 --> 00:04:00.349
而实际上只应该存在一条记录

00:04:00.349 --> 00:04:02.344
最后一部分是无效的

00:04:02.344 --> 00:04:05.465
其实这里还有其他昵称重复的病人

00:04:05.465 --> 00:04:07.150
Sandy Taylor 和 Sandra Taylor

00:04:07.150 --> 00:04:09.594
住在 2476 Fulton Street

00:04:09.594 --> 00:04:14.283
Pat 和 Patrick Gersten 住在 2778 North Avenue

00:04:14.283 --> 00:04:18.029
同样地 我们把这些记录下来

00:04:20.160 --> 00:04:24.355
现在我们继续对病人表中的体重列

00:04:24.355 --> 00:04:27.009
进行编程评估

00:04:27.009 --> 00:04:30.089
最低值是 48.8 磅

00:04:30.089 --> 00:04:33.304
对于一个大活人来说 这不可能

00:04:33.305 --> 00:04:37.199
至少是不准确的 也可能是无效的

00:04:37.199 --> 00:04:39.459
但如果我们更深一步地思考

00:04:39.459 --> 00:04:41.774
会发现两者都不是

00:04:41.774 --> 00:04:44.544
真实情况是 这其实是一致性问题

00:04:44.545 --> 00:04:47.035
48.8 其实是公斤 而不是磅

00:04:47.035 --> 00:04:49.510
我们可以通过名为 Zaitseva 这位病人的

00:04:49.509 --> 00:04:53.324
身高和 BMI 进行验证

00:04:53.324 --> 00:04:58.435
2.20462 是公斤和磅的转化系数

00:04:58.435 --> 00:05:04.524
703 乘以体重磅数 除以身高平方 这是 BMI 计算公式

00:05:04.524 --> 00:05:07.524
把 48.8 公斤转换为磅

00:05:07.524 --> 00:05:10.060
得到的结果是 19.1 BMI

00:05:10.060 --> 00:05:12.939
我们检查数据集中的 BMI

00:05:12.939 --> 00:05:16.175
与这个数字一样 或者如果在四舍五入之前 与这个数字相近

00:05:16.175 --> 00:05:19.220
所以这个 48.8 也是对的

00:05:19.220 --> 00:05:21.215
但是单位不对

00:05:21.214 --> 00:05:23.560
所以实际上是一致性问题

00:05:23.560 --> 00:05:25.899
这一般是因为录入数据的人

00:05:25.899 --> 00:05:28.894
有表格有误解或者疏忽造成的

00:05:28.894 --> 00:05:31.914
这个是非常需要解决的 因为我们需要

00:05:31.915 --> 00:05:33.580
为临床试验的每个治疗组

00:05:33.579 --> 00:05:35.969
上报平均指标比如体重、身高这些

00:05:35.970 --> 00:05:40.095
这里是问题的记录

00:05:40.095 --> 00:05:43.515
好了 现在是最后的编程评估

00:05:43.514 --> 00:05:48.680
对治疗表中 Auralin 和 Novodra 列运行 .isnull

00:05:48.680 --> 00:05:50.824
应该放至在 sum 的圆括号内

00:05:50.824 --> 00:05:53.750
这样会根据条目是否为空值

00:05:53.750 --> 00:05:57.000
返回一些说明真假的布尔数组

00:05:57.000 --> 00:05:59.670
可以对整个布尔数组进行求和

00:05:59.670 --> 00:06:01.530
真的为 1 假的为 0

00:06:01.529 --> 00:06:03.469
这个结果的意思就是

00:06:03.470 --> 00:06:07.285
Auralin 和 Novodra 列中都没有空值条目

00:06:07.285 --> 00:06:09.185
但情况其实不是这样的 对吧？

00:06:09.185 --> 00:06:11.449
如果我们向上滑动至对治疗表的目测评估

00:06:11.449 --> 00:06:15.769
这些破折号的条目其实是空值 或至少应该表达为空值

00:06:15.769 --> 00:06:18.555
这反应了多个数据集中的常见错误

00:06:18.555 --> 00:06:20.095
不仅是医护数据集

00:06:20.095 --> 00:06:22.385
即将缺失的值表达为其它东西

00:06:22.384 --> 00:06:25.250
比如说破折号、斜杠或 NaN (不适用)

00:06:25.250 --> 00:06:27.670
或者文本 None (空)

00:06:27.670 --> 00:06:30.335
如果下拉至我们的 info 编程评估

00:06:30.334 --> 00:06:33.649
会看到 Auralin 和 Novodra 列为对象或字符串

00:06:33.649 --> 00:06:37.669
这些破折号就不被认为是空值或没有值

00:06:37.670 --> 00:06:40.475
为什么这个问题这么重要 我们需要现在记录下来 之后解决呢？

00:06:40.475 --> 00:06:43.879
Pandas 和电子表格应用中的计算

00:06:43.879 --> 00:06:48.259
通常基于如何表达空值

00:06:48.259 --> 00:06:49.579
比如说 在 Pandas 中

00:06:49.579 --> 00:06:52.664
每一列或每一个数组只有一种数据类型

00:06:52.665 --> 00:06:55.010
我们不能将这些剂量的列转为值数据类型

00:06:55.009 --> 00:06:58.805
再进行平均值和标准偏差计算

00:06:58.805 --> 00:07:01.790
用来上报我们的临床试验发现

00:07:01.790 --> 00:07:03.160
但是再次强调 在 Google Sheets 或电子表格应用中

00:07:03.160 --> 00:07:06.275
空值也很重要

00:07:06.274 --> 00:07:09.799
电子表格应用一列中可以有多种数据类型存在

00:07:09.800 --> 00:07:14.090
比如这里 允许使用 40、50、破折号、破折号、破折号、60

00:07:14.089 --> 00:07:18.349
而这几个单元格 40、50、60 依然被认为是整数

00:07:18.350 --> 00:07:23.360
而这几个破折号单元格被认为是文本变量

00:07:23.360 --> 00:07:24.830
这一点很重要

00:07:24.829 --> 00:07:26.779
如果你想要使用函数 STDEVA

00:07:26.779 --> 00:07:30.419
计算这一列的标准偏差

00:07:30.420 --> 00:07:33.319
计算时 会把文本值

00:07:33.319 --> 00:07:36.526
也就是这里的破折号 设为零

00:07:36.526 --> 00:07:39.639
而如果这里没有内容 得到的计算结果就不同

00:07:39.639 --> 00:07:42.627
我这里展示给你看

00:07:42.627 --> 00:07:45.779
所以空值的正确表达很重要

00:07:45.779 --> 00:07:51.042
让我们记录下来

00:07:51.043 --> 00:07:58.519
这个是有效性问题 因为空值应该为空值 而不是文本

