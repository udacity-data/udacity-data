WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.530
大家好 希望你们已经准备好用 Python 来可视化数据了

00:00:04.530 --> 00:00:08.009
本课将使用 NumPy 和 Pandas 来存放数据

00:00:08.009 --> 00:00:12.265
用 Matplotlib 和 Seaborn 来创建可视化图表

00:00:12.265 --> 00:00:18.394
你可能见过 seaborn 的另一个缩写 sns 但本课要用的缩写是 sb

00:00:18.394 --> 00:00:22.359
而且本课所有代码都会用 Jupyter Notebook 来编写和运行

00:00:22.359 --> 00:00:26.189
使用这个魔法命令 (magic command) %matplotlib inline

00:00:26.190 --> 00:00:29.290
我们就能直接在 notebook 里绘制图表了

00:00:29.289 --> 00:00:32.240
本课要使用的数据集

00:00:32.240 --> 00:00:35.800
记录了精灵宝可梦系列游戏的角色数据

00:00:35.799 --> 00:00:38.199
数据集共有 807 行14 列

00:00:38.200 --> 00:00:42.390
既有分类变量也有数值变量

00:00:42.390 --> 00:00:45.369
我们先取数据集的一个分类变量 generation_id

00:00:45.369 --> 00:00:49.239
创建条形图

00:00:49.240 --> 00:00:51.645
虽然这一列的值看起来像数字

00:00:51.645 --> 00:00:55.230
但实际上是分类标签 表示各种宝可梦是在     

00:00:55.229 --> 00:00:59.054
游戏哪一代被引入的 (游戏共有七代)     

00:00:59.054 --> 00:01:03.530
要创建条形图 可用 seaborn 的 countplot 函数

00:01:03.530 --> 00:01:04.980
参数 data 代表数据来源

00:01:04.980 --> 00:01:07.850
我们将其设为 DataFrame pokemon

00:01:07.849 --> 00:01:12.054
设参数 x 为目标变量 generation_id

00:01:12.055 --> 00:01:15.780
我在语句最后加了分号 不过这不是严格必须的

00:01:15.780 --> 00:01:19.655
加了分号 图表绘制对象的信息就不会显示出来了

00:01:19.655 --> 00:01:23.859
由图可知 大多数宝可梦都是在第一代、

00:01:23.859 --> 00:01:27.924
第三代和第五代引入的 而第六代和第七代则是宝可梦引入最少的两代

00:01:27.924 --> 00:01:30.879
默认设置有一点不好

00:01:30.879 --> 00:01:34.084
那就是条形颜色各不相同

00:01:34.084 --> 00:01:38.169
x 轴已经表明了是游戏的第几代

00:01:38.170 --> 00:01:42.359
没必要用不同的颜色再来表明不同的代数

00:01:42.359 --> 00:01:47.069
因此 为了避免分散注意力 我们最好只用一种颜色

00:01:47.069 --> 00:01:51.534
我用 seaborn 的color_palette 函数来获取颜色值

00:01:51.534 --> 00:01:54.269
该函数会根据参数的设置

00:01:54.269 --> 00:01:57.289
返回一个颜色元组的列表

00:01:57.290 --> 00:01:59.795
由于我没有指定参数

00:01:59.795 --> 00:02:02.519
所以函数会返回现在的默认色板

00:02:02.519 --> 00:02:04.494
因为我只想要一种颜色

00:02:04.495 --> 00:02:07.300
所以我用索引 0 进行切片 取得列表的第一个元素

00:02:07.299 --> 00:02:10.585
并将其赋给变量 base_color

00:02:10.585 --> 00:02:12.870
然后在函数 countplot 中

00:02:12.870 --> 00:02:16.125
把颜色参数 color 的值设为该颜色值

00:02:16.125 --> 00:02:20.490
修改后效果如图 干净多了

00:02:20.840 --> 00:02:24.775
现在我们可能想

00:02:24.775 --> 00:02:29.105
根据每一代引入的宝可梦种类数量来给各代排序

00:02:29.104 --> 00:02:32.959
因此我们可以在函数 countplot 中使用参数 order

00:02:32.960 --> 00:02:35.530
这个参数接受一个列表     

00:02:35.530 --> 00:02:38.099
即各个条形的排序列表

00:02:38.099 --> 00:02:40.060
因此我们可以根据目前尚未排序的图表

00:02:40.060 --> 00:02:42.759
对相应的值进行硬编码

00:02:42.759 --> 00:02:47.149
比如 我们可以先输入 5 以此类推 最后输入 6

00:02:47.150 --> 00:02:51.405
但更好的办法是编写代码 让程序自动排序

00:02:51.405 --> 00:02:55.349
而这就是 pandas series 的 value_counts 函数派上用场的时候了

00:02:55.349 --> 00:02:57.400
该函数会统计

00:02:57.400 --> 00:03:01.379
Series 唯一值的频率 并进行降序排列

00:03:01.379 --> 00:03:03.139
为了给条形排序

00:03:03.139 --> 00:03:05.250
我们得获取索引 (.index)

00:03:05.250 --> 00:03:06.740
并将这些索引赋给一个变量

00:03:06.740 --> 00:03:11.469
将该变量传递给 order 参数实现对条形的排序

00:03:11.469 --> 00:03:16.060
我们来看另一个分类变量 宝可梦的属性

00:03:16.060 --> 00:03:19.289
每种宝可梦都有一到两种属性

00:03:19.289 --> 00:03:22.889
与其攻击、防御能力有关

00:03:22.889 --> 00:03:27.459
我们先来看第一个属性 (type_1) 的分布

00:03:27.460 --> 00:03:29.215
生成条形图

00:03:29.215 --> 00:03:34.069
不难发现 x 轴上的标签重叠了 难以阅读

00:03:34.069 --> 00:03:36.539
我们可以使用

00:03:36.539 --> 00:03:40.750
matplotlib 的 xticks 函数来旋转类别标签

00:03:40.750 --> 00:03:43.330
将旋转度 rotation 设为 90

00:03:43.330 --> 00:03:47.890
标签就会逆时针旋转 90 度 不再相互重叠了

00:03:47.889 --> 00:03:51.750
我们也可以创建横向条形图来解决这个问题

00:03:51.750 --> 00:03:56.530
在 seaborn 里 要实现这一点 只需将参数 x 改为 y 即可

00:03:56.530 --> 00:03:59.370
这样属性变量的类别就落在了纵轴上

00:03:59.370 --> 00:04:02.754
频率则落在了 x 轴上

00:04:02.754 --> 00:04:05.340
根据属性频率对图表进行排序

00:04:05.340 --> 00:04:08.650
我们就可以看到第一属性为水系和一般系的宝可梦最多

00:04:08.650 --> 00:04:12.599
飞行系的则最少

