WEBVTT
Kind: captions
Language: zh-CN

00:00:00.420 --> 00:00:04.330
现在我们已经来到了高斯朴素贝叶斯算法

00:00:04.330 --> 00:00:05.385
的文档页面

00:00:05.385 --> 00:00:08.100
sklearn.naive_bayes.GaussianNB

00:00:08.100 --> 00:00:11.450
这就是我要找的算法

00:00:11.450 --> 00:00:15.650
我找到了需要的 sklearn 文档页面

00:00:15.650 --> 00:00:18.410
一开始就能看到的这些内容 同时也是

00:00:18.410 --> 00:00:22.960
我喜欢 sklearn 文档的一个原因 就是它有大量的实例

00:00:22.960 --> 00:00:25.640
当我在编写用在这门课程里的代码时

00:00:25.640 --> 00:00:28.550
我总是先找到这些示例代码

00:00:28.550 --> 00:00:31.030
然后在我的 Python 解释器里试着运行一遍

00:00:31.030 --> 00:00:32.549
看看能否成功

00:00:32.549 --> 00:00:36.110
几乎所有代码都能正常运行

00:00:36.110 --> 00:00:37.570
这样事情就很简单了

00:00:37.570 --> 00:00:39.620
只需要关注几行重要的代码就可以了

00:00:39.620 --> 00:00:41.110
我先把这些代码指给你看

00:00:41.110 --> 00:00:45.640
然后我会向你展示给之前那个实例所实际编写的代码

00:00:45.640 --> 00:00:48.250
之后你就能开始认识这些代码了

00:00:48.250 --> 00:00:49.180
我们先来介绍一下

00:00:49.180 --> 00:00:52.430
第一行非常重要的代码是这里

00:00:53.550 --> 00:00:56.950
之前的代码只是用来生成一些可以利用的训练点而已

00:00:56.950 --> 00:00:57.790
就不那么重要了

00:00:57.790 --> 00:01:01.790
这是重点的开始部分 就是这个 import 语句

00:01:01.790 --> 00:01:04.540
如果你之前用过 Python  那你应该对 import 语句很熟悉

00:01:04.540 --> 00:01:08.480
这个语句的作用是把外部模块导入你的代码中间

00:01:08.480 --> 00:01:12.360
所以你不必每次都完全重新实现所有代码

00:01:12.360 --> 00:01:15.470
你可以使用他人编写好的代码

00:01:15.470 --> 00:01:19.380
所以我们从 sklearn.naive_bayes 引入 GaussianNB 模块

00:01:19.380 --> 00:01:20.350
很好

00:01:20.350 --> 00:01:23.020
接下来 我们要利用这些内容

00:01:23.020 --> 00:01:24.210
创建分类器

00:01:24.210 --> 00:01:27.040
把 GaussianNB() 赋给 clf(分类器)

00:01:27.040 --> 00:01:28.790
如果缺少 import 语句

00:01:28.790 --> 00:01:29.840
比如你忘了添加这行

00:01:29.840 --> 00:01:32.480
那么运行时这一行就会报错

00:01:32.480 --> 00:01:36.030
所以如果你看到某些错误显示

00:01:36.030 --> 00:01:37.570
无法识别这个函数

00:01:37.570 --> 00:01:40.350
那么问题很可能就出在你的 import 语句上

00:01:40.350 --> 00:01:42.510
我们创建好了分类器

00:01:42.510 --> 00:01:45.290
代码也可以投入使用了

00:01:45.290 --> 00:01:47.360
接下来要做的就是进行拟合

00:01:48.550 --> 00:01:51.710
注意 我们已经用和 “训练” 等价的 “拟合” 进行表示

00:01:51.710 --> 00:01:54.790
这里是我们实际给出训练数据的地方

00:01:54.790 --> 00:01:57.070
它会学习各种模式

00:01:57.070 --> 00:02:00.030
然后就形成了我们刚刚创建的分类器

00:02:00.030 --> 00:02:03.870
我们在分类器上调用 fit 函数 接下来将两个参数传递给 fit 函数

00:02:03.870 --> 00:02:10.000
一个是特征 X 一个是标签 Y

00:02:10.000 --> 00:02:13.100
用 fit 函数进行监督分类的过程都是这样

00:02:13.100 --> 00:02:14.740
调用 fit 函数

00:02:14.740 --> 00:02:16.400
输入特征

00:02:16.400 --> 00:02:17.190
而后输入标签

00:02:18.600 --> 00:02:22.060
最后 我们让已完成训练的分类器

00:02:22.060 --> 00:02:24.300
进行一些预测

00:02:24.300 --> 00:02:25.470
我们给它一个新的数据点

00:02:25.470 --> 00:02:29.320
本示例中是 -0.8、-1

00:02:29.320 --> 00:02:32.880
我们想知道的是 这个特定点对应的标签应该是什么？

00:02:32.880 --> 00:02:35.370
它属于什么类？

00:02:35.370 --> 00:02:38.390
在这个示例中 分类器将该点归在了 “1” 这个分类下

00:02:38.390 --> 00:02:42.480
或者你可以设想一下 对于其他点分类器可能会将其归在 “2” 这个分类下

00:02:42.480 --> 00:02:47.600
当然了 你必须先训练好分类器

00:02:47.600 --> 00:02:48.850
才能调用分类器上的 predict 函数进行预测

00:02:48.850 --> 00:02:50.500
因为使用数据拟合的过程就是

00:02:50.500 --> 00:02:51.590
它实际学习所有模式的过程

00:02:51.590 --> 00:02:55.140
然后分类器能利用学得的模式来进行预测

00:02:55.140 --> 00:02:56.530
这就是整个过程

00:02:56.530 --> 00:02:59.380
现在你已经了解了上述过程

00:02:59.380 --> 00:03:02.200
它们就是第一个示例的内容

