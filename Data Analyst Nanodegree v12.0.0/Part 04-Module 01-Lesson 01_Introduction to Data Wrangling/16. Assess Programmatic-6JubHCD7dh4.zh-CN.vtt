WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.799
如果我们多滚动一下 DataFrame

00:00:02.799 --> 00:00:06.309
我们会注意到 Pandas 自动折叠较大数据集的一些列和行

00:00:06.309 --> 00:00:10.390
比如这里

00:00:10.390 --> 00:00:13.810
在第 29 行和第 18,971 行之间

00:00:13.810 --> 00:00:16.824
所有行都是使用省略号折叠的

00:00:16.824 --> 00:00:20.919
如果我们向右滚动 并检查所有列 发现也是一样的

00:00:20.920 --> 00:00:25.330
duration (在职时间)和 salary (工资) 之间的各列也是使用这些省略号折叠

00:00:25.329 --> 00:00:29.679
Pandas 这样处理 是因为查看大数据集会占用太多空间

00:00:29.679 --> 00:00:33.054
滚动起来也会令人头疼

00:00:33.054 --> 00:00:35.085
这也是我之前谈到的缺点

00:00:35.085 --> 00:00:37.512
即在 Pandas 中难以进行目测评估

00:00:37.512 --> 00:00:41.699
展开这些列和行过于繁琐

00:00:41.700 --> 00:00:46.590
在 Jupyter notebook 单元格中上下和横向滚动也非易事

00:00:46.590 --> 00:00:52.140
相反 我喜欢用 Pandas 的INFO函数获得更多关于我们数据集的信息

00:00:52.140 --> 00:00:54.734
这就是一种编程评估

00:00:54.734 --> 00:00:57.034
这个函数极为简单

00:00:57.034 --> 00:00:58.454
我们键入 DataFrame 的名称

00:00:58.454 --> 00:01:01.644
即 df 然后 .info

00:01:01.645 --> 00:01:03.570
这时候 我将会再次利用 SHIFT+TAB

00:01:03.570 --> 00:01:07.081
探索这个函数的 Signature 和 Docstring

00:01:07.081 --> 00:01:11.040
好的 Signature、df.info 和 Docstring

00:01:11.040 --> 00:01:13.005
DataFrame 的简明摘要

00:01:13.004 --> 00:01:15.949
Docstring 告诉我们这个函数的作用

00:01:15.950 --> 00:01:18.030
DataFrame 的简明摘要

00:01:18.030 --> 00:01:20.969
好的 我们将处理这个单元格 SHIFT+ENTER

00:01:20.969 --> 00:01:23.177
这就是简明摘要

00:01:23.177 --> 00:01:26.954
我们得到 19,001 行和 24 列

00:01:26.954 --> 00:01:30.385
然后 一连串关于下方各列的信息

00:01:30.385 --> 00:01:33.000
包括这些列的值的类型和

00:01:33.000 --> 00:01:36.632
DataFrame 的总内存使用量

00:01:36.632 --> 00:01:38.844
好的 我们再仔细检查这些列

00:01:38.844 --> 00:01:41.025
什么是 ApplicationP ？

00:01:41.025 --> 00:01:42.792
什么是 AboutC？

00:01:42.792 --> 00:01:48.045
优质数据的基本要素之一是具有描述性变量和值名称

00:01:48.045 --> 00:01:54.245
即使表示必要资格的 RequiredQual 也不是描述性变量

00:01:54.245 --> 00:01:57.980
JobRequirment 有个小小的输入错误

00:01:57.980 --> 00:02:00.646
虽然它的描述性足够了 但如果可以的话 你也可能需要修复它

00:02:00.646 --> 00:02:04.659
我们做下记录 以便在清洁时处理所有问题

