WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.775
Python Quest 库令 HTTP 请求变得简单

00:00:04.775 --> 00:00:08.685
它有一种名为 get 的方法 将为我们发送请求

00:00:08.685 --> 00:00:11.940
返回我们请求的文件的内容 对我们而言

00:00:11.939 --> 00:00:16.199
它是一个文本文件 我们可以保存至文件中

00:00:16.199 --> 00:00:20.054
这是我们通过编程从互联网下载文件的方式

00:00:20.054 --> 00:00:22.464
这就是操作方法 超级简单

00:00:22.464 --> 00:00:24.225
我们导入请求库

00:00:24.225 --> 00:00:26.570
我们实际上导入的是 OS 库

00:00:26.570 --> 00:00:31.370
所以 我们可以将下载的文件存储至 名为 ebert_reviews 的文件夹中

00:00:31.370 --> 00:00:35.950
如果尚不存在 这部分代码会创建文件夹 ebert_reviews

00:00:35.950 --> 00:00:38.425
这是实际的请求代码

00:00:38.424 --> 00:00:41.254
我们在 URL 上使用 requests.get

00:00:41.255 --> 00:00:43.695
然后返回一个响应

00:00:43.695 --> 00:00:45.679
在这里 我会给你这个 URL

00:00:45.679 --> 00:00:48.719
这是 Roger Ebert 影评文本文件的 URL

00:00:48.719 --> 00:00:52.174
我已保存在新的 Udacity 的服务器上

00:00:52.174 --> 00:00:54.534
所以 实际上 我们并未将响应保存至任何文件夹中

00:00:54.534 --> 00:00:57.599
但我们来看看这个响应变量的样子

00:00:57.600 --> 00:01:00.265
我们看看响应 200

00:01:00.265 --> 00:01:05.590
200 表示请求的 HTTP 状态代码 已成功

00:01:05.590 --> 00:01:10.829
所以 很好 这就是 request.get 法返回的响应

00:01:10.829 --> 00:01:12.450
你目前还看不到它

00:01:12.450 --> 00:01:14.780
但我们文本文件中的所有文本实际上

00:01:14.780 --> 00:01:19.355
还在我们计算机的工作记忆中 目前在这个响应变量内

00:01:19.355 --> 00:01:24.425
它存储在响应主体中 我们可以用 .content 访问它

00:01:24.424 --> 00:01:29.215
如请求库文档中所示 我们来一探究竟

00:01:29.215 --> 00:01:31.445
好的 这就是全部操作

00:01:31.444 --> 00:01:33.429
它采用字节格式

00:01:33.430 --> 00:01:36.130
使用这个基本文件 IO

00:01:36.129 --> 00:01:39.209
我们把这个文件保存至计算机中

00:01:39.209 --> 00:01:46.439
这样我们将打开一个名为 11-e.t-the-extra-terrestrial.txt 的文件 即

00:01:46.439 --> 00:01:49.295
这个 URL 中最后一个斜线后的所有内容

00:01:49.295 --> 00:01:51.644
要想获得最后一个斜线后的所有内容

00:01:51.644 --> 00:01:53.685
我们将使用 Python 的 split 函数

00:01:53.685 --> 00:01:56.085
然后选择所返回名单中的最后一个项目

00:01:56.084 --> 00:01:58.679
我们需要打开这个文件

00:01:58.680 --> 00:02:01.620
接着将把响应变量的内容写入至该文件中

00:02:01.620 --> 00:02:04.895
我们必须在 WB 即 Write Binary 模式下打开这个文件

00:02:04.894 --> 00:02:09.764
这是因为 response.content 是字节格式 而不是文本格式 但请不要担心

00:02:09.764 --> 00:02:13.089
当我们稍后在 文本编辑器 或 Pandas 中打开这些文件时

00:02:13.090 --> 00:02:16.409
字节将渲染为人类可读文本

00:02:16.409 --> 00:02:21.145
接着 我们写入至我们已打开的文件句柄中 即 file.write response.content

00:02:21.145 --> 00:02:23.529
这样就行了

00:02:23.530 --> 00:02:26.550
这就是如何通过编程下载一个文件的方法

00:02:26.550 --> 00:02:29.365
我们来查看一下我们文件夹 ebert_reviews 的内容

00:02:29.365 --> 00:02:32.685
以保证这种方法有效 就是这样

00:02:32.685 --> 00:02:35.460
这个 .DS_Store 是一个隐藏文件

00:02:35.460 --> 00:02:38.224
它存储了我们文件夹的属性 请暂时忽略这一点

00:02:38.224 --> 00:02:41.055
如果你转至 Jupyter Notebook 控制面板

00:02:41.055 --> 00:02:42.390
然后打开这个文件

00:02:42.389 --> 00:02:46.019
你就会发现整个文件已正确下载

00:02:46.020 --> 00:02:48.409
再说一下 这就是如何下载一个文件的方法

00:02:48.409 --> 00:02:50.805
但如果我们有许多文件要下载

00:02:50.805 --> 00:02:55.918
就像我们针对烂番茄百佳影片的全部 Ebert 影评所做的事情一样

00:02:55.918 --> 00:02:59.280
那么写许多这样的语句 就会让人恼火

00:02:59.280 --> 00:03:02.745
幸运的是 也可以通过编程下载文件

00:03:02.745 --> 00:03:08.080
你可以对所有文件 URL 使用 for 循环 以减少代码重复

00:03:08.080 --> 00:03:11.844
你们很幸运 在这里 我已经为你们提供了 URL

00:03:11.844 --> 00:03:13.919
你们现在的任务就是写这个循环

00:03:13.919 --> 00:03:17.239
然后通过编程下载所有的 Roger Ebert 影评文件

