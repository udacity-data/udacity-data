WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.784
这里显示的是

00:00:01.784 --> 00:00:05.070
烂番茄网站《ET 外星人》的 HTML 数据

00:00:05.070 --> 00:00:07.530
HTML 文件是可以在 Sublime 等文本编辑器中

00:00:07.530 --> 00:00:11.019
打开和检查的文本文件

00:00:11.019 --> 00:00:15.509
这也就是说 你可以编写自己的代码 来解析或理解文本

00:00:15.509 --> 00:00:17.879
当然 这里顶部有一些令人混淆的代码

00:00:17.879 --> 00:00:20.279
但网页的实际文本内容

00:00:20.280 --> 00:00:25.740
比如名称和影评人及观众评分 则是相当简单的

00:00:25.739 --> 00:00:28.004
比如 要获得观众评分指标

00:00:28.004 --> 00:00:32.954
我们可以在文本中找到 span 标签的所有实例 其方法是

00:00:32.954 --> 00:00:37.640
利用像 Python str.find 函数或被称作正则表达式的更神奇的工具

00:00:37.640 --> 00:00:40.435
来搜索和提取文本中的模式

00:00:40.435 --> 00:00:42.740
但再说一次 在我们之前

00:00:42.740 --> 00:00:45.910
人们就开始以一种神奇的方式解决这个问题

00:00:45.909 --> 00:00:50.659
Beautiful Soup 是一个采用 Python 编程语言编写的 HTML 解析器

00:00:50.659 --> 00:00:53.389
这个名称源自于 TagSoup 一词

00:00:53.390 --> 00:00:58.895
这与大多数网站上找到的几乎不可解析的非结构化 HTML 有关

00:00:58.895 --> 00:01:00.679
如果愿意 你可以暂停视频 花上一秒钟的时间阅读

00:01:00.679 --> 00:01:04.629
库里相当具有说服力的证明

00:01:04.629 --> 00:01:09.359
所以 我们利用它从《ET 外星人》 HTML 页面上提取电影名称

00:01:09.359 --> 00:01:14.680
我们稍后在合并所有已收集数据时会需要这个名称

00:01:14.680 --> 00:01:16.864
接着 我们转至文档

00:01:16.864 --> 00:01:20.599
你需要做的第一件事是制作 soup

00:01:20.599 --> 00:01:24.649
也就是说 将引导至 HTML 文件的路径传递给文件句柄

00:01:24.650 --> 00:01:28.825
然后将文件句柄传递至 Beautiful Soup 构造函数 就像这样

00:01:28.825 --> 00:01:32.082
这是导入本课程 Beautiful Soup 库后的情景

00:01:32.082 --> 00:01:36.066
我们对存储在 rt_html 文件夹中的

00:01:36.066 --> 00:01:39.200
烂番茄网站《ET 外星人》 HTML 试试这个方法。

00:01:39.200 --> 00:01:40.564
这是我们的文件路径

00:01:40.564 --> 00:01:43.519
我们将它传递至文件句柄 文件

00:01:43.519 --> 00:01:45.125
它们的文件句柄是 FP

00:01:45.125 --> 00:01:47.420
但我们一直这么使用文件 所以我们坚持这么做

00:01:47.420 --> 00:01:49.519
Beautiful Soup 给出这个警告

00:01:49.519 --> 00:01:52.280
它是在告诉我们 我们没有指定一个具体的解析器

00:01:52.280 --> 00:01:55.010
如果愿意 你可以暂停视频 花一点时间 阅读这段文字

00:01:55.010 --> 00:01:59.385
默认情况下 它们会为我们挑选最受欢迎的解析器 叫做 lxml

00:01:59.385 --> 00:02:03.185
我们实际上进入这个解析器中 以摆脱警告

00:02:03.185 --> 00:02:06.745
我们有自己的 Soup 即我们的 Beautilful Soup

00:02:06.745 --> 00:02:09.830
这看起来确实像一个 HTML 文件 但实际上

00:02:09.830 --> 00:02:12.410
我们可以用 Beautiful Soup 库中的方法来

00:02:12.409 --> 00:02:16.000
从这个 HTML 中轻松找到并提取数据

00:02:16.000 --> 00:02:19.354
最受欢迎的方法之一就是 find 法

00:02:19.354 --> 00:02:22.294
我们来利用这种方法来找出我们的影片名称

00:02:22.294 --> 00:02:25.514
暂停视频 花上一秒钟的时间来阅读第一段

00:02:25.514 --> 00:02:27.984
你或许不会马上明白它的含义 但很快就会明白的

00:02:27.985 --> 00:02:33.500
我向你保证 好的 我们利用 find 从 HTML 中获得我们影片的名称

00:02:33.500 --> 00:02:35.735
想想 Beautiful Soup 的 find 法

00:02:35.735 --> 00:02:37.877
就像文本编辑器中的 find 功能一样

00:02:37.877 --> 00:02:39.740
比如

00:02:39.740 --> 00:02:41.564
Control+F 或 Command+F

00:02:41.564 --> 00:02:43.900
如果我们搜索名称标签

00:02:43.900 --> 00:02:47.705
我们会发现整个 HTML 文档中只有一个

00:02:47.705 --> 00:02:50.240
我们想要的电影名称就在这个标签内

00:02:50.240 --> 00:02:52.800
ET 外星人 1982年

00:02:52.800 --> 00:02:57.865
这就是它在 Beautiful Soup 代码中的模样 就这样

00:02:57.865 --> 00:03:00.165
这个名称实际上就是网页的名称

00:03:00.164 --> 00:03:03.794
而不是你能够在这里见到的电影的名称

00:03:03.794 --> 00:03:05.754
要想仅得到电影名称

00:03:05.754 --> 00:03:10.715
我们必须进行一些简单的字符串截取 以便除去它

00:03:10.715 --> 00:03:14.134
 - rotten tomatoes

00:03:14.134 --> 00:03:18.399
不用担心 我们能够做到 好的 比如说 要想访问这个标签的内容

00:03:18.400 --> 00:03:21.235
不论这些开放标签和闭合标签之中有什么

00:03:21.235 --> 00:03:23.500
我们都可以使用 .contents

00:03:23.500 --> 00:03:28.645
contents 返回一个标签 children 的名单 名单就在这里

00:03:28.645 --> 00:03:31.080
由于这个标签之中只有一个对象

00:03:31.080 --> 00:03:35.940
所以 名单中也只有一个项目 我们不能使用索引 0 来访问

00:03:35.939 --> 00:03:38.530
这就是仅仅为了获得电影名称和电影发行年份

00:03:38.530 --> 00:03:41.435
而所做的字符串截取的情形

00:03:41.435 --> 00:03:44.770
字符串截取仅抓取从字符串中第一个字符

00:03:44.770 --> 00:03:48.680
到倒数第 18 个字符的内容

00:03:48.680 --> 00:03:55.460
字符串 - rotten tomatoes的长度 为 18 个字符

00:03:55.460 --> 00:04:00.776
所以 xa0 是不间断空格的 Unicode编码

00:04:00.776 --> 00:04:02.905
我们稍后会讲到 Unicaode 编码

00:04:02.905 --> 00:04:05.449
所以 如果你现在还不明白 请不要担心

00:04:05.449 --> 00:04:07.079
我之所以提出这一点 是因为

00:04:07.080 --> 00:04:11.790
原始的 Top 100 TSV 文件实际上在电影末尾和电影发行年份

00:04:11.789 --> 00:04:15.399
之间并没有不间断空格

00:04:15.399 --> 00:04:16.764
它只有一个正常空格

00:04:16.764 --> 00:04:19.229
所以 我们在清理时必须进行标准化

00:04:19.230 --> 00:04:22.645
这样 我们以后就能在名称列合并 DataFrame

00:04:22.644 --> 00:04:24.685
在这堂课中 我们实际上并未进行任何清理

00:04:24.685 --> 00:04:26.120
暂时只要记住它就行

