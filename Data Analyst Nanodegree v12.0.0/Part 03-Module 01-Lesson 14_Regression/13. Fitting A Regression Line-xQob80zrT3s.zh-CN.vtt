WEBVTT
Kind: captions
Language: zh-CN

00:00:02.529 --> 00:00:04.820
在双变量案例中

00:00:04.820 --> 00:00:07.849
我们想要找到一条直线能够

00:00:07.849 --> 00:00:11.509
让我们很好地利用解释变量预测反应变量

00:00:11.509 --> 00:00:14.480
用于发现最佳直线的主要算法是

00:00:14.480 --> 00:00:17.925
最小二乘回归算法

00:00:17.925 --> 00:00:22.339
选择直线的方法是

00:00:22.339 --> 00:00:27.884
对拟合直线和每个点之间的垂直距离平方的总和进行最小化

00:00:27.885 --> 00:00:29.510
让我们来看一下原理

00:00:29.510 --> 00:00:31.760
设想这是相同的点集

00:00:31.760 --> 00:00:34.940
我们想要拟合这两条直线

00:00:34.939 --> 00:00:38.164
我们通过观察这些距离

00:00:38.164 --> 00:00:41.640
决定应该选择两条直线中的哪一条

00:00:41.640 --> 00:00:44.795
但是如果我们只用这些值的总和

00:00:44.795 --> 00:00:49.189
正负数可以会最后抵消掉每条直线

00:00:49.189 --> 00:00:51.140
所以我们不是简单求和

00:00:51.140 --> 00:00:53.825
而是对这些距离的平方求和

00:00:53.825 --> 00:00:56.885
然后找到最小化的一条直线

00:00:56.884 --> 00:01:00.140
我们可以这样以符号表示差异

00:01:00.140 --> 00:01:04.310
然后目标是最小化这个函数

00:01:04.310 --> 00:01:06.740
也就是说 对于数据集中的每个点

00:01:06.739 --> 00:01:11.000
观察预计值和实际值的距离

00:01:11.000 --> 00:01:14.340
进行平方 然后求和

00:01:14.340 --> 00:01:19.159
如果有条直线得到的值比其他值更小

00:01:19.159 --> 00:01:22.045
那么这就是我们想要使用的直线

00:01:22.045 --> 00:01:25.250
你可能会想 我们为什么选择这个函数呢？

00:01:25.250 --> 00:01:28.280
为什么不使用绝对值 而是使用平方呢？

00:01:28.280 --> 00:01:32.180
为什么不使用指数将所有值变成整数呢？

00:01:32.180 --> 00:01:36.830
实际上许多函数可供选择 进行优化

00:01:36.829 --> 00:01:42.724
但是它的数学特性 让这个特殊的函数很不错

00:01:42.724 --> 00:01:47.174
一些函数基于微积分理论 一些只是基于传统理论

00:01:47.174 --> 00:01:49.700
大多数情况下 你实际上自己无法

00:01:49.700 --> 00:01:52.625
计算这些值 但是软件可以做到

00:01:52.625 --> 00:01:55.730
例如你在 Python 中默认完成的事情

00:01:55.730 --> 00:01:58.820
这样可能很好地适用于大部分数据集

00:01:58.819 --> 00:02:02.119
如果你决定想以不同方式将这个问题最优化

00:02:02.120 --> 00:02:05.000
你可以自己编写一个程序

