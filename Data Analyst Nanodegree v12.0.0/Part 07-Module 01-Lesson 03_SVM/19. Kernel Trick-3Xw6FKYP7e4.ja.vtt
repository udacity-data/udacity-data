WEBVTT
Kind: captions
Language: ja

00:00:00.120 --> 00:00:03.350
セバスチャン、これは便利だけれどとても難しい機能のように思えます。

00:00:03.350 --> 00:00:06.610
新しいfeatureを自分で書かないといけないのでしょう？

00:00:06.610 --> 00:00:09.820
SVMの素晴らしいところは、それをしなくて大丈夫な点です。

00:00:09.820 --> 00:00:12.950
"Kernel Trick"と呼ばれるものがあります。

00:00:12.950 --> 00:00:16.160
"Kernel Trick"について解説してくれるんですよね。信じてます。(笑)

00:00:16.160 --> 00:00:19.030
いいえ、ダメです（笑）。ヒントだけあげましょう。

00:00:19.030 --> 00:00:24.280
SVMには、低次元つまり少ないfeatureの座標を

00:00:24.280 --> 00:00:28.670
高次元の座標へとマッピングする機能があります。

00:00:28.670 --> 00:00:33.470
先ほどお見せしたように、線形の境界を引けなかった座標を

00:00:33.470 --> 00:00:36.560
引けるものへと変換してしまいました。

00:00:36.580 --> 00:00:40.390
詳細は説明しませんが、こういった機能のことを"Kernel"と呼んでいます。

00:00:40.390 --> 00:00:43.856
是非kernelについて調べて見てください。featureを受け取るだけではなく

00:00:43.856 --> 00:00:47.810
様々な２つのinputを受け取るファンクションです。

00:00:47.810 --> 00:00:51.520
そしてkernel trickを使って、入力をx,yだけから拡張すると

00:00:51.520 --> 00:00:57.360
SVMを使ってデータの境界線を作ることができ

00:00:57.360 --> 00:01:03.109
さらに元の座標上に、その境界線を書き戻すことができます。

00:01:03.110 --> 00:01:06.160
知っている通り、これは非線形の境界線です。

00:01:06.180 --> 00:01:09.900
これがSVMの素晴らしいところです。

00:01:09.900 --> 00:01:15.410
最適な線形の境界線を見つけるシンプルなアイディアを検討したり、

00:01:15.410 --> 00:01:20.950
実際に境界線を見つけるといった作業は、kernelTrickを使って

00:01:20.950 --> 00:01:27.040
高次元の座標で行えば良いのです。
それを元の座標上に、非線形の境界線として描くための

00:01:27.040 --> 00:01:32.950
素晴らしく効率的で強力な仕組みはSVMが用意しているのです。

00:01:32.950 --> 00:01:34.840
これは本当に素晴らしい機能ですし

00:01:34.840 --> 00:01:39.050
機械学習の中でも、最も重要な機能の一つです。

