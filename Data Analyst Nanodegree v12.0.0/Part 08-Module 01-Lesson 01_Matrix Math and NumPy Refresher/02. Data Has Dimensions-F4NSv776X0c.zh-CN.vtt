WEBVTT
Kind: captions
Language: zh-CN

00:00:00.740 --> 00:00:03.421
神经网络可以对大量数据执行大量运算

00:00:03.420 --> 00:00:05.419
但是在自己开始设计这些网络

00:00:05.419 --> 00:00:08.779
并正确设定了相关数学公式之前

00:00:08.779 --> 00:00:12.599
我们首先需要了解如何表示这些数据

00:00:12.599 --> 00:00:16.350
具体而言 我们需要思考数据可能具备的分布形状

00:00:16.350 --> 00:00:19.140
例如 可能有一个数字

00:00:19.140 --> 00:00:21.060
表示人的身高（厘米）

00:00:21.060 --> 00:00:22.529
或者有一系列的数字

00:00:22.530 --> 00:00:26.789
表示此人的各种特征 例如身高 体重和年龄

00:00:26.789 --> 00:00:28.599
或者有一张关于此人的图片

00:00:28.600 --> 00:00:31.200
它由某种网格构成 每个位置都是

00:00:31.199 --> 00:00:32.939
一个像素

00:00:32.939 --> 00:00:35.460
表示该图片中单个像素的一种方法是

00:00:35.460 --> 00:00:38.370
使用三个数字

00:00:38.369 --> 00:00:41.393
分别表示红色 蓝色和绿色通道的值

00:00:41.393 --> 00:00:42.809
我们用它们的纬度的数量

00:00:42.810 --> 00:00:45.359
来描述各种数据形状

00:00:45.359 --> 00:00:49.229
首先是最小 最简单的形状 即单个值

00:00:49.229 --> 00:00:53.589
例如 1 2.4 或 -0.3

00:00:53.590 --> 00:00:55.540
这些叫做标量

00:00:55.539 --> 00:00:56.380
我们可以看出

00:00:56.380 --> 00:00:58.000
标量的维度为零

00:00:58.000 --> 00:01:00.429
我们无法可视化零维度

00:01:00.429 --> 00:01:01.659
但是不用管

00:01:01.659 --> 00:01:03.709
标量就是这么定义的

00:01:03.710 --> 00:01:05.920
所以 在之前的例子中

00:01:05.920 --> 00:01:08.950
人的身高是标量 形状是零维度

00:01:08.950 --> 00:01:11.890
此外 还有由一列数据构成的数 叫做向量

00:01:11.890 --> 00:01:14.829
向量包括两种类型 行向量和列向量

00:01:14.828 --> 00:01:16.119
它们可以存储相同的内容

00:01:16.120 --> 00:01:18.161
但抽象地想 你可以将行向量

00:01:18.161 --> 00:01:21.700
想象成从左到右水平排列的 [1 2 3]

00:01:21.700 --> 00:01:26.020
将列向量看做从上到下排列的

00:01:26.019 --> 00:01:27.759
[1 2 3]

00:01:27.760 --> 00:01:29.920
使用哪一种向量

00:01:29.920 --> 00:01:31.611
通常只是个人喜好问题

00:01:31.611 --> 00:01:33.069
但是有时候 向量的形状

00:01:33.069 --> 00:01:35.119
会影响到数学运算（的形式）

00:01:35.120 --> 00:01:38.140
但不管怎么说 向量是一维的量

00:01:38.140 --> 00:01:39.459
我们称其为长度

00:01:39.459 --> 00:01:42.179
所以这两个向量的长度都为 3

00:01:42.180 --> 00:01:44.650
我们之前的列表 关于一个人的身高

00:01:44.650 --> 00:01:47.109
体重和年龄 可以存储为向量

00:01:47.109 --> 00:01:49.040
接着是矩阵

00:01:49.040 --> 00:01:52.330
矩阵是二维的值

00:01:52.329 --> 00:01:53.920
我们用行数和列数

00:01:53.920 --> 00:01:56.989
来描述矩阵的形状

00:01:56.989 --> 00:02:01.179
如果有这两行数据 [1 2 3] 和 [4 5 6]

00:02:01.180 --> 00:02:03.670
则是两行及三列

00:02:03.670 --> 00:02:06.049
我们称其为 2 x 3 的矩阵

00:02:06.049 --> 00:02:08.859
如果图片中的每个像素有一个数字

00:02:08.860 --> 00:02:12.300
那么可以将这些像素值存储到矩阵中

00:02:12.300 --> 00:02:14.829
最后是张量

00:02:14.829 --> 00:02:16.620
你将在这门课程中经常听到张量一词

00:02:16.620 --> 00:02:18.286
因为你将花大量时间

00:02:18.286 --> 00:02:20.259
使用一种叫做 TensorFlow 的软件库

00:02:20.259 --> 00:02:23.340
该库的所有数据都是张量形式

00:02:23.340 --> 00:02:26.039
张量可以指任何 n 维的

00:02:26.039 --> 00:02:27.299
值集合

00:02:27.300 --> 00:02:29.990
总结一下 标量是零维张量

00:02:29.990 --> 00:02:32.520
向量是一维张量

00:02:32.520 --> 00:02:35.400
矩阵是二维张量

00:02:35.400 --> 00:02:37.110
任何大于二维的对象

00:02:37.110 --> 00:02:38.870
我们就称为张量

00:02:38.870 --> 00:02:40.610
问题是 更高维度的数据

00:02:40.610 --> 00:02:42.730
难以可视化

00:02:42.729 --> 00:02:45.799
对于三维 你可以想象成矩阵堆栈

00:02:45.800 --> 00:02:49.160
但是也可以想象成矩阵列表

00:02:49.159 --> 00:02:51.129
或向量矩阵

00:02:51.129 --> 00:02:53.780
对于四维 可以想象成一种矩阵

00:02:53.780 --> 00:02:55.699
其中每个项目本身

00:02:55.699 --> 00:02:58.399
都是一个矩阵 或一个矩阵列表的列表

00:02:58.400 --> 00:03:01.241
或者还可以是其他形式

00:03:01.241 --> 00:03:02.990
随着维度的增多

00:03:02.990 --> 00:03:04.760
越来越复杂

00:03:04.759 --> 00:03:05.840
要记住的一点是

00:03:05.840 --> 00:03:07.520
即使很难想象

00:03:07.520 --> 00:03:09.500
数据是如何组织的 我们依然能

00:03:09.500 --> 00:03:11.060
对它们进行数学进行运算

00:03:11.060 --> 00:03:12.800
回到之前的示例

00:03:12.800 --> 00:03:14.840
如果图片每个像素的每个颜色通道

00:03:14.840 --> 00:03:16.819
都有一个单独的值

00:03:16.819 --> 00:03:19.219
我们可以将这些值存储为三维张量

00:03:19.219 --> 00:03:22.686
并用单独的平面表示红色 绿色和蓝色值

00:03:22.686 --> 00:03:24.560
在接下来的几节课中

00:03:24.560 --> 00:03:26.810
我们将主要讲解标量和矩阵

00:03:26.810 --> 00:03:29.629
对于向量 我们可以将其看做矩阵

00:03:29.629 --> 00:03:31.930
其中一个维度的大小是 1

00:03:31.930 --> 00:03:33.680
例如 对于之前这些

00:03:33.680 --> 00:03:35.870
长度为 3 的向量

00:03:35.870 --> 00:03:39.370
可以将这个行向量看做 1 x 3 的矩阵

00:03:39.370 --> 00:03:42.650
将这个列向量看做 3 x 1 的矩阵

00:03:42.650 --> 00:03:45.510
我们有时候还需要指代矩阵中的

00:03:45.509 --> 00:03:47.340
某个特定元素（数）

00:03:47.340 --> 00:03:51.530
我们通过索引（即行和列位置）进行指代

00:03:51.530 --> 00:03:54.439
如果这个矩阵称为 A

00:03:54.439 --> 00:03:56.379
则它各个位置的数可以被这样指代

00:03:56.379 --> 00:04:01.310
第一行的索引是 a11 a12

00:04:01.310 --> 00:04:02.680
和 a13

00:04:02.680 --> 00:04:07.025
第二行的索引是 a21 a22

00:04:07.025 --> 00:04:09.719
和 a23 等等

00:04:09.719 --> 00:04:12.606
所以 a32 的值是 8

00:04:12.606 --> 00:04:13.939
最后提醒下

00:04:13.939 --> 00:04:16.850
在数学课本及网上资料中

00:04:16.850 --> 00:04:19.120
甚至这节课的大部分内容中

00:04:19.120 --> 00:04:20.720
索引通常都从 1 开始 例如这里所显示的

00:04:20.720 --> 00:04:23.840
第一行从 1 开始

00:04:23.839 --> 00:04:25.129
第一列也从 1 开始

00:04:25.129 --> 00:04:26.899
从 1 开始数很合理

00:04:26.899 --> 00:04:29.779
但是在编程语言中 索引通常

00:04:29.779 --> 00:04:32.479
都是从 0 开始 就像这样

00:04:32.480 --> 00:04:35.670
所有索引都比你认为的小 1

00:04:35.670 --> 00:04:39.199
所以在代码中 8 的索引不是 a32

00:04:39.199 --> 00:04:41.231
而是 a21

00:04:41.232 --> 00:04:43.190
如果你有编程经验的话

00:04:43.189 --> 00:04:44.350
或许已经习惯这种索引表示方法

00:04:44.350 --> 00:04:46.480
只需记住 大部分的书面材料

00:04:46.480 --> 00:04:47.600
索引都从 1 开始

00:04:47.600 --> 00:04:49.070
但是如果你是编程新手的话

00:04:49.069 --> 00:04:51.110
肯定需要一些时间

00:04:51.110 --> 00:04:53.289
才能习惯于从 0 开始这种表示方法

