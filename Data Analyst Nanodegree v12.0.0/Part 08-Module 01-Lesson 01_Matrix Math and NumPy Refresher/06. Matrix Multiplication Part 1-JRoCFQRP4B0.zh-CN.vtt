WEBVTT
Kind: captions
Language: zh-CN

00:00:00.500 --> 00:00:02.990
之前 我们讨论了对逐个元素进行的

00:00:02.990 --> 00:00:03.730
矩阵运算

00:00:03.730 --> 00:00:05.480
这实际上包含了大量

00:00:05.480 --> 00:00:06.730
神经网络会涉及的数学运算

00:00:06.730 --> 00:00:08.850
但是提到乘法的话

00:00:08.850 --> 00:00:11.190
就会有点难度了

00:00:11.190 --> 00:00:15.370
现在 我们将一个矩阵与它自己相乘 得到它的平方

00:00:15.380 --> 00:00:17.710
如果看结果的话 很容易看出

00:00:17.710 --> 00:00:21.040
每个值是如何得出的 1 x 1 = 1

00:00:21.050 --> 00:00:24.300
2 x 2 = 4 3 x 3 = 9 等等

00:00:24.300 --> 00:00:27.550
这种逐个元素相乘是一种运算

00:00:27.550 --> 00:00:27.560
但是大多数情况下 人们所说的矩阵乘法
这种逐个元素相乘是一种运算

00:00:27.560 --> 00:00:30.610
但是大多数情况下 人们所说的矩阵乘法

00:00:30.620 --> 00:00:32.390
并不是这种情况

00:00:32.390 --> 00:00:34.850
实际上指的是一种特殊的运算

00:00:34.850 --> 00:00:38.450
叫做矩阵积 结果是这样的

00:00:38.450 --> 00:00:41.290
现在看答案的话 可能不清楚

00:00:41.290 --> 00:00:41.300
这些数字都是从何而来的
现在看答案的话 可能不清楚

00:00:41.300 --> 00:00:43.280
这些数字都是从何而来的

00:00:43.280 --> 00:00:44.440
还有一个区别

00:00:44.450 --> 00:00:47.350
我们提到逐个元素矩阵运算

00:00:47.350 --> 00:00:49.000
要求矩阵大小相同

00:00:49.000 --> 00:00:52.540
例如 如图的逐个元素乘法是可行的

00:00:52.540 --> 00:00:54.970
但是如果想计算这两个相同矩阵的矩阵积

00:00:54.970 --> 00:00:57.140
则无法计算

00:00:57.140 --> 00:00:58.190
这是个很迷惑人的知识点

00:00:58.190 --> 00:00:59.570
而且当你开始

00:00:59.570 --> 00:01:00.950
构建神经网络时

00:01:00.950 --> 00:01:02.530
肯定会出几次错误

00:01:02.530 --> 00:01:02.540
但这将是最常见的运算
肯定会出几次错误

00:01:02.540 --> 00:01:04.820
但这将是最常见的运算

00:01:04.820 --> 00:01:07.200
所以一定要明白

00:01:07.200 --> 00:01:09.010
我们是如何计算

00:01:09.010 --> 00:01:10.930
两个矩阵的积呢？

00:01:10.930 --> 00:01:12.620
在处理矩阵之前

00:01:12.620 --> 00:01:15.650
我们先从两个长度相等的向量开始讨论

00:01:15.650 --> 00:01:17.680
我们可以对这些向量进行

00:01:17.680 --> 00:01:17.690
点积运算
我们可以对这些向量进行

00:01:17.690 --> 00:01:19.460
点积运算

00:01:19.460 --> 00:01:21.040
对于这节课

00:01:21.040 --> 00:01:22.700
你不需要了解点积的用途

00:01:22.700 --> 00:01:25.150
但是如果你感兴趣的话 可以访问视频下方的链接

00:01:25.150 --> 00:01:26.810
要计算点积

00:01:26.810 --> 00:01:30.060
我们首先将每个向量的相应元素相乘

00:01:30.060 --> 00:01:34.230
所以是 0 x 1 2 x 7 等等

00:01:34.230 --> 00:01:37.730
然后将所有这些结果相加 得出一个数字

00:01:37.730 --> 00:01:37.740
即 180
然后将所有这些结果相加 得出一个数字

00:01:37.740 --> 00:01:39.780
即 180

00:01:39.780 --> 00:01:43.100
这种运算基本上可以计算任何两个向量

00:01:43.100 --> 00:01:45.320
只要长度相等即可

00:01:45.320 --> 00:01:46.870
然后将这些向量转换为单个数字

00:01:46.870 --> 00:01:49.430
那么这种运算可以如何帮助我们将两个矩阵相乘呢？

00:01:49.430 --> 00:01:52.200
实际上 要计算两个矩阵的积

00:01:52.200 --> 00:01:55.010
我们对左边矩阵的每行

00:01:55.010 --> 00:01:57.710
与右边矩阵的每列求点积

00:01:57.710 --> 00:01:59.430
一定要记住这点

00:01:59.430 --> 00:02:01.590
每次对两个矩阵相乘

00:02:01.590 --> 00:02:04.290
都是将第一个矩阵的每行

00:02:04.290 --> 00:02:06.540
与第二个矩阵的每列相乘

00:02:06.540 --> 00:02:09.410
我们稍后会讨论相关的细节

00:02:09.410 --> 00:02:11.720
现在先看个示例

00:02:11.720 --> 00:02:11.730
要计算这两个矩阵的点积
现在先看个示例

00:02:11.730 --> 00:02:14.200
要计算这两个矩阵的点积

00:02:14.210 --> 00:02:15.840
我们先计算

00:02:15.840 --> 00:02:17.810
左侧矩阵的第一行

00:02:17.810 --> 00:02:19.900
与右侧矩阵的第一列的点积

00:02:19.900 --> 00:02:22.340
暂时先忽略所有其他数字

00:02:22.340 --> 00:02:24.680
然后可以将这行和这列看成

00:02:24.680 --> 00:02:26.840
两个长度相等的向量

00:02:26.840 --> 00:02:29.780
现在计算它们的点积 这行从左往右

00:02:29.780 --> 00:02:33.150
这列从上往下

00:02:33.150 --> 00:02:35.930
和之前一样 0 x 1

00:02:35.930 --> 00:02:38.180
2 x 7 等等

00:02:38.180 --> 00:02:40.220
这行和这列的点积

00:02:40.220 --> 00:02:43.220
计算得目标矩阵中的一个元素

00:02:43.220 --> 00:02:45.780
它索引的行数和列数与

00:02:45.780 --> 00:02:48.300
计算它所用矩阵的行和列相同

00:02:48.300 --> 00:02:51.090
因为我们使用的是左侧矩阵的第 1 行

00:02:51.090 --> 00:02:54.810
和右侧矩阵的第 1 列 所以答案位于新矩阵的

00:02:54.810 --> 00:02:56.310
第 1 行第 1 列

00:02:56.310 --> 00:02:59.180
如果我们使用了左侧矩阵的第 2 行

00:02:59.180 --> 00:03:03.270
和右侧矩阵的第 3 列 答案就会变成第 2 行第 3 列

00:03:03.270 --> 00:03:05.370
所有这些运算步骤只是

00:03:05.370 --> 00:03:07.330
算出新矩阵的一个元素

00:03:07.330 --> 00:03:09.530
要算出整个结果 我们需要计算

00:03:09.530 --> 00:03:11.660
这个矩阵的所有行与

00:03:11.660 --> 00:03:13.430
这个矩阵所有列的点积

00:03:13.430 --> 00:03:15.310
第二个矩阵有 3 列

00:03:15.310 --> 00:03:17.150
意味着第一个矩阵每行都需要

00:03:17.150 --> 00:03:19.430
计算三个点积

00:03:19.430 --> 00:03:21.650
因为第一个矩阵有两行

00:03:21.650 --> 00:03:23.990
所以对于这个矩阵乘法

00:03:23.990 --> 00:03:26.660
我们一共需要计算 6 个点积

00:03:26.660 --> 00:03:26.670
我们已经算出一个点积了
我们一共需要计算 6 个点积

00:03:26.670 --> 00:03:27.620
我们已经算出一个点积了

00:03:27.620 --> 00:03:29.030
要计算剩下的五个

00:03:29.030 --> 00:03:31.670
只需对每个行列对重复相同流程即可

00:03:31.680 --> 00:03:34.370
第 1 行和第 2 列的点积

00:03:34.370 --> 00:03:36.650
变成第 1 行第 2 列的项

00:03:36.650 --> 00:03:38.960
然后计算第 1 行和第 3 列的点积

00:03:38.960 --> 00:03:40.870
完成对这行的运算

00:03:40.870 --> 00:03:42.750
然后对下一行执行相同的计算流程

00:03:42.750 --> 00:03:47.310
算出第 2 行第 1 列的点积  第 2 行第 2 列

00:03:47.310 --> 00:03:48.160
第 2 行第 3 列

00:03:48.160 --> 00:03:49.620
所有运算都结束后

00:03:49.620 --> 00:03:51.240
最终得出我们想要的

00:03:51.240 --> 00:03:52.330
矩阵乘法结果

00:03:52.330 --> 00:03:53.750
计算量很大啊

00:03:53.750 --> 00:03:53.760
答案矩阵只有 6 个数字
计算量很大啊

00:03:53.760 --> 00:03:55.670
答案矩阵只有 6 个数字

00:03:55.680 --> 00:03:57.120
但是要计算这 6 个数字

00:03:57.120 --> 00:04:00.080
我们进行了 24 次乘法 18 次加法

00:04:00.080 --> 00:04:02.540
随着矩阵的增大 计算流程更复杂

00:04:02.540 --> 00:04:04.750
我猜 这就是为何我们让计算机来完成这些运算吧

00:04:04.750 --> 00:04:05.810
我之前提到

00:04:05.810 --> 00:04:08.290
我们有时候无法计算两个矩阵的积

00:04:08.290 --> 00:04:10.160
在下个视频中 我将详细介绍这一点

00:04:10.160 --> 00:04:13.450
并介绍一些重要的矩阵乘法技巧

