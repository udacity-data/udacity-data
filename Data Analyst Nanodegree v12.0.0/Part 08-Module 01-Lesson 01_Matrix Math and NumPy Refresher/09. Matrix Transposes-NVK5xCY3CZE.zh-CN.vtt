WEBVTT
Kind: captions
Language: zh-CN

00:00:00.050 --> 00:00:02.049
你已经明白矩阵形状

00:00:02.049 --> 00:00:03.769
对数学运算的影响

00:00:03.770 --> 00:00:06.019
现在你需要知道一个重要的知识

00:00:06.019 --> 00:00:07.949
即矩阵转置

00:00:07.950 --> 00:00:10.620
矩阵转置是一种运算 得到矩阵的元素的

00:00:10.619 --> 00:00:11.789
值和原来的一样

00:00:11.789 --> 00:00:14.309
但是行和列的位置被交换了

00:00:14.310 --> 00:00:17.980
所以这个方阵的转置是这个矩阵

00:00:17.980 --> 00:00:20.910
可以看到原始矩阵第 1 行的值

00:00:20.910 --> 00:00:24.954
1 2 3 现在变成转置矩阵第 1 列的值

00:00:24.954 --> 00:00:27.329
原始矩阵第 2 行和第 3 行

00:00:27.329 --> 00:00:29.879
也变成了转置矩阵的第 2 列和

00:00:29.879 --> 00:00:31.089
第 3 列

00:00:31.089 --> 00:00:33.320
非方阵矩阵也是这种情况

00:00:33.320 --> 00:00:35.712
这个矩阵的转置是这个矩阵

00:00:35.712 --> 00:00:37.670
同样 可以看出原始矩阵的行

00:00:37.670 --> 00:00:39.780
变成了转置矩阵的列

00:00:39.780 --> 00:00:41.910
我们只是交换行和列

00:00:41.909 --> 00:00:44.159
但是转置有两个重要特征

00:00:44.159 --> 00:00:47.659
首先 如果原始矩阵不是方阵

00:00:47.659 --> 00:00:50.969
那么转置矩阵就会变成新的形状

00:00:50.969 --> 00:00:51.659
因为维度进行了交换

00:00:51.659 --> 00:00:55.911
所以 4 x 2 矩阵的转置是 2 x 4 矩阵

00:00:55.911 --> 00:00:57.119
有时候这种转置有帮助

00:00:57.119 --> 00:00:58.952
例如 如果要计算矩阵乘法

00:00:58.953 --> 00:01:01.140
但是矩阵间的形状

00:01:01.140 --> 00:01:02.640
不匹配

00:01:02.640 --> 00:01:05.849
第二个重要特征是转置矩阵中的数据

00:01:05.849 --> 00:01:08.759
与原始矩阵的数据排列方式不一样

00:01:08.760 --> 00:01:11.219
如果原始矩阵表示几行数据

00:01:11.219 --> 00:01:13.760
那么转置矩阵将表示几列数据

00:01:13.760 --> 00:01:15.690
如果原始矩阵按列排列

00:01:15.689 --> 00:01:17.947
那么转置矩阵将按行排列

00:01:17.947 --> 00:01:19.530
如果觉得听起来很抽象的话

00:01:19.530 --> 00:01:22.370
我们来看个示例 了解下我说的

00:01:22.370 --> 00:01:24.030
数据按行或列排列的意思

00:01:24.030 --> 00:01:26.549
假设有个矩阵存储的是

00:01:26.549 --> 00:01:28.379
三个人的身高 体重和年龄

00:01:28.379 --> 00:01:31.560
我们可以将每个人的数据存储为一行

00:01:31.560 --> 00:01:33.390
或一列

00:01:33.390 --> 00:01:35.280
如果选择行的话

00:01:35.280 --> 00:01:38.219
那么每列就表示所有三个人的某个特征

00:01:38.219 --> 00:01:40.329
例如身高 体重或年龄

00:01:40.329 --> 00:01:42.810
但是 如果将每个人的数据按列存储

00:01:42.810 --> 00:01:46.230
那么每行就包含特定特征的所有值

00:01:46.230 --> 00:01:49.170
但是现在假设我们查看转置矩阵

00:01:49.170 --> 00:01:52.350
之前的行变成了列 反之亦然

00:01:52.349 --> 00:01:54.000
我已经提过好几次

00:01:54.000 --> 00:01:55.731
如果要对两个矩阵相乘

00:01:55.731 --> 00:01:57.689
其实处理的是左侧矩阵的行

00:01:57.689 --> 00:01:59.250
与右侧矩阵的列

00:01:59.250 --> 00:02:01.840
这就是为何前面的讨论内容很重要

00:02:01.840 --> 00:02:03.390
如果有个数学问题是

00:02:03.390 --> 00:02:05.609
处理一个人的所有特征

00:02:05.609 --> 00:02:08.159
那么可能与处理所有人的单个特征

00:02:08.159 --> 00:02:09.590
不一样

00:02:09.590 --> 00:02:11.280
很有可能只有一种情况

00:02:11.280 --> 00:02:13.140
是你要寻找的答案

00:02:13.139 --> 00:02:15.909
当你构建神经网络时 就会遇到这种情况

00:02:15.909 --> 00:02:18.180
有时候某些矩阵运算将不可行

00:02:18.180 --> 00:02:21.180
因为形状不对

00:02:21.180 --> 00:02:22.950
然后你会发现

00:02:22.949 --> 00:02:25.079
当你进行转置后 就可以了

00:02:25.080 --> 00:02:28.800
例如也许你要将这个 3 x 2 和 4 x 2 的矩阵相乘

00:02:28.800 --> 00:02:30.510
在矩阵乘法课程中

00:02:30.509 --> 00:02:32.717
你已经明白这不可行

00:02:32.717 --> 00:02:33.719
因为他们的大小不兼容

00:02:33.719 --> 00:02:36.659
注意 内侧的这两个数字需要相同

00:02:36.659 --> 00:02:38.969
但是这里是 2 这里是 4

00:02:38.969 --> 00:02:42.330
但是如果对 4 x 2 的矩阵进行转置

00:02:42.330 --> 00:02:44.430
则是 2 x 4 的矩阵

00:02:44.430 --> 00:02:47.700
现在就可以将 3 x 2 和 2 x 4 的矩阵相乘了

00:02:47.699 --> 00:02:50.009
或者回去看看另一个选择

00:02:50.009 --> 00:02:53.399
你可以对 3 x 2 的矩阵转置

00:02:53.400 --> 00:02:57.210
得出 2 x 3 的矩阵 然后交换顺序

00:02:57.210 --> 00:03:00.659
将 4 x 2 和 2 x 3 的矩阵相乘

00:03:00.659 --> 00:03:03.120
从数学角度看 二者都可行

00:03:03.120 --> 00:03:06.060
但问题是 遇到这种情况

00:03:06.060 --> 00:03:08.939
你应该采取其中的哪一种方法呢？

00:03:08.939 --> 00:03:11.009
答案是视情况而定

00:03:11.009 --> 00:03:12.618
我们只需知道何时使用哪个方式即可

00:03:12.618 --> 00:03:14.909
我们再回来试着

00:03:14.909 --> 00:03:17.129
将 3 x 2 和 4 x 2 这两个矩阵相乘

00:03:17.129 --> 00:03:20.009
我们已经演示了如何使用转置

00:03:20.009 --> 00:03:21.699
通过两种方式使这一乘法可行

00:03:21.699 --> 00:03:24.689
但是我们来看看这两种方法是否合适

00:03:24.689 --> 00:03:26.139
如果两个矩阵包含的数据

00:03:26.139 --> 00:03:29.849
都按行排列 那么两种情况都可行

00:03:29.849 --> 00:03:32.400
对第二个矩阵转置后

00:03:32.400 --> 00:03:34.650
得出行乘以列

00:03:34.650 --> 00:03:37.230
这正是矩阵乘法所需的情形

00:03:37.229 --> 00:03:39.959
答案是这个 3 x 4 的矩阵

00:03:39.960 --> 00:03:42.120
第二种方法 即对第一个矩阵转置

00:03:42.120 --> 00:03:44.550
然后交换顺序

00:03:44.550 --> 00:03:47.070
也得出了行乘以列

00:03:47.069 --> 00:03:49.859
这次将是这个 4 x 3 的矩阵

00:03:49.860 --> 00:03:50.640
不错

00:03:50.639 --> 00:03:53.189
如果两个原始矩阵存储的都是行数据

00:03:53.189 --> 00:03:54.528
那么就可以使用转置

00:03:54.528 --> 00:03:56.069
顺便提下 你可能没有注意到

00:03:56.069 --> 00:03:58.319
但实际上这两种乘法的答案

00:03:58.319 --> 00:04:00.689
相互是转置矩阵

00:04:00.689 --> 00:04:03.060
所以两种情况都得出相同的数字

00:04:03.060 --> 00:04:04.620
只是形状不一样

00:04:04.620 --> 00:04:06.360
意味着你可以选择任一方法

00:04:06.360 --> 00:04:08.820
具体取决于你希望结果是何种大小

00:04:08.819 --> 00:04:09.819
这样可行了

00:04:09.819 --> 00:04:12.000
但是如果原始矩阵的数据

00:04:12.000 --> 00:04:13.979
按列排列呢？

00:04:13.979 --> 00:04:16.480
这样的话 两种方法都不可行

00:04:16.480 --> 00:04:17.550
我们来看看为何

00:04:17.550 --> 00:04:19.889
如果我们对第二个矩阵转置

00:04:19.889 --> 00:04:22.829
那么就会将错误的元素与点积相加

00:04:22.829 --> 00:04:25.169
如果查看这行和这列

00:04:25.170 --> 00:04:28.014
结果就是将 1 和 0 相乘

00:04:28.014 --> 00:04:29.430
每个都来自原始矩阵的

00:04:29.430 --> 00:04:31.319
第一组数据项

00:04:31.319 --> 00:04:34.459
然后我们会将其与

00:04:34.459 --> 00:04:38.609
2 和 3（第二组数据项）的积相加

00:04:38.610 --> 00:04:41.050
所以在对这两个矩阵相乘时

00:04:41.050 --> 00:04:44.819
每个点积都会与每个数据项的值相加

00:04:44.819 --> 00:04:47.399
而不是我们希望的结果

00:04:47.399 --> 00:04:49.229
即将相关项的元素相加

00:04:49.230 --> 00:04:51.900
这就像我之前描述的情况

00:04:51.899 --> 00:04:54.029
也许现在我们查看的是所有人的身高

00:04:54.029 --> 00:04:57.089
而不是一个人的所有数据

00:04:57.089 --> 00:04:59.659
所以对 4 x 2 矩阵转置

00:04:59.660 --> 00:05:01.270
并不能得出我们希望的答案

00:05:01.269 --> 00:05:02.979
那么第二种方法呢？

00:05:02.980 --> 00:05:05.020
现在对第一个矩阵转置

00:05:05.019 --> 00:05:06.250
然后交换

00:05:06.250 --> 00:05:08.579
但是出现了相同的问题

00:05:08.579 --> 00:05:11.740
数据在左侧排列成列 在右侧排列成行

00:05:11.740 --> 00:05:13.930
如果原始 3 x 2 矩阵排列成行

00:05:13.930 --> 00:05:16.689
4 x 2 矩阵排列成列

00:05:16.689 --> 00:05:18.021
结果会怎样？

00:05:18.021 --> 00:05:19.480
实际上可行

00:05:19.480 --> 00:05:21.021
因为我们一开始就是想

00:05:21.021 --> 00:05:22.189
这么计算乘法的

00:05:22.189 --> 00:05:25.089
遗憾的是 这里两种方法都不行

00:05:25.089 --> 00:05:27.310
第一种方法得出行乘以行

00:05:27.310 --> 00:05:30.040
第二种方法得出列乘以列

00:05:30.040 --> 00:05:31.600
那么最后一种可能性呢

00:05:31.600 --> 00:05:35.410
原始 3 x 2 矩阵排列成列

00:05:35.410 --> 00:05:37.570
4 x 2 矩阵排列成行

00:05:37.569 --> 00:05:41.550
结果变成列乘以行或列乘以列

00:05:41.550 --> 00:05:43.300
无论何种方法

00:05:43.300 --> 00:05:44.185
都无法得出你想要的答案

00:05:44.185 --> 00:05:46.060
所以看来 唯一能够在矩阵乘法中

00:05:46.060 --> 00:05:48.490
安全地使用转置的情况就是

00:05:48.490 --> 00:05:50.889
原始的两个矩阵中的数据

00:05:50.889 --> 00:05:52.360
都排列成行

00:05:52.360 --> 00:05:54.400
我并不是说你始终需要

00:05:54.399 --> 00:05:55.839
将数据存储为行

00:05:55.839 --> 00:05:58.119
有时候存储为列更合适

00:05:58.120 --> 00:06:00.280
但是注意 在某些情况下

00:06:00.279 --> 00:06:02.199
如果使用转置

00:06:02.199 --> 00:06:03.439
可以使某些数学运算可行

00:06:03.439 --> 00:06:05.654
你可能会遇到这种情形

00:06:05.654 --> 00:06:07.779
那么你需要停下来好好思考下

00:06:07.779 --> 00:06:09.189
每个矩阵的数据情况

00:06:09.189 --> 00:06:11.139
确保知道哪些行和列

00:06:11.139 --> 00:06:14.139
需要进行计算 仅在这些行和列

00:06:14.139 --> 00:06:16.938
不会造成干扰的情况下使用转置

