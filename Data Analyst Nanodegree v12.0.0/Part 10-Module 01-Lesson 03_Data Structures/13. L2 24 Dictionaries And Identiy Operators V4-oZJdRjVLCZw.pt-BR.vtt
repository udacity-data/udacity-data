WEBVTT
Kind: captions
Language: pt-BR

00:00:00.558 --> 00:00:01.916
ESTRUTURAS DE DADOS

00:00:01.949 --> 00:00:03.920
DICIONÁRIOS
E OPERADORES DE IDENTIDADE

00:00:04.490 --> 00:00:06.775
Os conjuntos são estruturas
simples de dados

00:00:06.808 --> 00:00:10.358
e têm um uso principal:
coletar elementos únicos.

00:00:10.391 --> 00:00:14.661
A próxima estrutura de dados -
o dicionário - é mais flexível.

00:00:14.694 --> 00:00:16.725
Em vez de armazenar
objetos únicos -

00:00:16.758 --> 00:00:18.799
como as listas
e os conjuntos fazem -,

00:00:18.832 --> 00:00:21.293
os dicionários armazenam
pares de elementos,

00:00:21.326 --> 00:00:23.453
chaves e valores.

00:00:23.486 --> 00:00:25.945
Neste exemplo,
definimos um dicionário,

00:00:25.978 --> 00:00:28.268
no qual as chaves
são os nomes dos elementos

00:00:28.301 --> 00:00:31.651
e os valores,
os números atômicos correspondentes.

00:00:31.684 --> 00:00:33.923
Podemos procurar valores
em um dicionário

00:00:33.956 --> 00:00:37.107
usando colchetes
para fechar uma chave.

00:00:37.140 --> 00:00:40.091
Também podemos inserir
novos valores ao dicionário

00:00:40.124 --> 00:00:41.715
com colchetes.

00:00:41.748 --> 00:00:45.989
Aqui adicionamos o lítio
e atribuímos o valor 3.

00:00:46.022 --> 00:00:49.105
As chaves do dicionário
parecem os índices das listas.

00:00:49.138 --> 00:00:51.653
Selecionamos elementos
de uma estrutura de dados

00:00:51.686 --> 00:00:54.316
colocando a chave
entre colchetes.

00:00:54.349 --> 00:00:55.709
Diferente das listas,

00:00:55.742 --> 00:00:58.830
os dicionários podem ter chaves
de qualquer tipo imutável,

00:00:58.863 --> 00:01:00.477
não só de inteiros.

00:01:00.510 --> 00:01:04.261
O dicionário do elemento
usa strings para as chaves.

00:01:04.294 --> 00:01:06.964
Porém, não é necessário
que toda chave

00:01:06.997 --> 00:01:08.677
tenha o mesmo tipo.

00:01:09.349 --> 00:01:12.315
Podemos conferir se um valor
está no dicionário

00:01:12.348 --> 00:01:15.777
assim como checamos se um valor
está na lista ou no conjunto,

00:01:15.810 --> 00:01:17.579
com a palavra-chave "in".

00:01:17.612 --> 00:01:21.353
Podemos usar "in" para verificar
se uma chave está no dicionário

00:01:21.386 --> 00:01:23.033
antes de procurá-la,

00:01:23.066 --> 00:01:26.241
caso haja a possibilidade
de a chave não estar lá.

00:01:26.274 --> 00:01:29.217
"Mithril" não fazia parte
do dicionário de elementos,

00:01:29.250 --> 00:01:31.442
então False foi impresso.

00:01:31.475 --> 00:01:35.050
Os dicionários têm um método
parecido que é muito útil,

00:01:35.083 --> 00:01:38.329
o get, que procura por valores
no dicionário.

00:01:38.362 --> 00:01:41.554
Mas, diferente dos colchetes,
ele retorna None

00:01:41.587 --> 00:01:43.698
ou um valor padrão
de sua escolha

00:01:43.731 --> 00:01:45.857
se a chave
não for encontrada.

00:01:45.890 --> 00:01:48.288
"Dilithium"
não está no dicionário,

00:01:48.321 --> 00:01:51.075
então None é retornado
e impresso.

00:01:51.108 --> 00:01:53.740
Se você espera que as buscas
falhem às vezes,

00:01:53.773 --> 00:01:57.163
o get pode ser uma escolha melhor
do que os colchetes,

00:01:57.196 --> 00:01:59.388
pois os erros podem travar
o programa,

00:01:59.421 --> 00:02:00.731
e isso não é bom.

00:02:00.764 --> 00:02:03.156
Podemos conferir se uma chave
retorna None

00:02:03.189 --> 00:02:04.698
com o operador is

00:02:04.731 --> 00:02:08.606
ou podemos conferir o contrário
usando o is not.

00:02:08.639 --> 00:02:11.349
Eles são chamados
de "operadores de identidade".

00:02:11.382 --> 00:02:14.034
Veremos mais sobre eles

00:02:14.067 --> 00:02:17.259
e como se diferem
dos operadores de comparação

00:02:17.292 --> 00:02:21.213
"igual a" e "não igual a"
nos quizzes a seguir.

