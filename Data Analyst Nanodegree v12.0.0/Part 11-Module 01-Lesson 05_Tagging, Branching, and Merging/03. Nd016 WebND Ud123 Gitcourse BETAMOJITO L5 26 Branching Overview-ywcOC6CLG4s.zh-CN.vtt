WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.504
这是我们在上节课中建立的示例 git 仓库

00:00:04.504 --> 00:00:06.585
这个仓库中只有一些提交

00:00:06.585 --> 00:00:08.339
其中一个提交上有一个标签

00:00:08.339 --> 00:00:10.894
除了标签 还有一个分支

00:00:10.894 --> 00:00:13.515
它一直是隐藏的 现在让我们来看看它

00:00:13.515 --> 00:00:18.170
默认的第一个分支名称是 master 这并不是什么特殊名称

00:00:18.170 --> 00:00:21.210
它只是 git 提供的默认名称而已

00:00:21.210 --> 00:00:22.515
现在最酷的部分来了

00:00:22.515 --> 00:00:25.710
当在仓库中进行提交时 该提交会被添加到分支上

00:00:25.710 --> 00:00:29.380
分支指针也会移动并指向它

00:00:29.379 --> 00:00:30.798
很巧妙吧？

00:00:30.798 --> 00:00:34.289
相信你还记得 标签是关联于某次提交的永久指针

00:00:34.289 --> 00:00:38.814
它不会移动 但在添加新的提交时 分支却会移动

00:00:38.814 --> 00:00:42.899
让我们在仓库中再添加一个分支 并将其称为 sidebar

00:00:42.899 --> 00:00:44.738
为什么要这样做呢？

00:00:44.738 --> 00:00:48.059
这是因为 分支非常强大 我们可以借助它

00:00:48.060 --> 00:00:52.380
在不同的隔离环境中对同一个项目进行操作

00:00:52.380 --> 00:00:54.895
让我们集中精神 来看看它是如何工作的

00:00:54.895 --> 00:00:56.804
你可能会问的一个问题是

00:00:56.804 --> 00:00:58.320
如果我们现在进行提交

00:00:58.320 --> 00:01:00.070
哪个分支会移动呢？

00:01:00.070 --> 00:01:03.450
是 master 还是 sidebar？

00:01:03.450 --> 00:01:06.445
现在 我们需要揭示另外一个隐藏的东西

00:01:06.444 --> 00:01:09.119
那就是命名很奇怪的 HEAD 指针

00:01:09.120 --> 00:01:11.609
它指向当前活跃的分支

00:01:11.609 --> 00:01:14.170
现在它指向 master 分支

00:01:14.171 --> 00:01:16.980
因此 master 是活跃的分支

00:01:16.980 --> 00:01:20.969
我们可以使用 checkout 命令来切换它所指向的分支

00:01:20.969 --> 00:01:23.010
要切换到 sidebar 分支

00:01:23.010 --> 00:01:26.120
需要使用命令 git checkout sidebar

00:01:26.120 --> 00:01:29.255
让我们用 git checkout master 再切换回去

00:01:29.254 --> 00:01:31.304
如果我们现在进行提交

00:01:31.305 --> 00:01:34.140
该提交就会被添加到 HEAD 所指向的分支

00:01:34.140 --> 00:01:37.680
因为 HEAD 表示当前分支 (即活跃分支)

00:01:37.680 --> 00:01:40.875
让我们切换到 sidebar 分支 并在那里添加一个提交

00:01:40.875 --> 00:01:42.861
现在 HEAD 指向 sidebar

00:01:42.861 --> 00:01:46.840
因此 现在作出的提交将添加到 sidebar 分支

00:01:46.840 --> 00:01:49.530
我们不仅可以拥有尽可能多的分支

00:01:49.530 --> 00:01:51.960
还可以选择分支从哪里开始

00:01:51.959 --> 00:01:55.819
假设我们的标题存在问题 是在提交 a 中引入的

00:01:55.819 --> 00:01:59.314
我们可以在那里使用 branch 命令创建一个新的分支

00:01:59.314 --> 00:02:03.299
使用 checkout 命令切换到它

00:02:03.299 --> 00:02:10.164
然后进行必要的修改来解决问题

00:02:10.164 --> 00:02:13.884
这里需要指出一个不容忽视的基本要点

00:02:13.884 --> 00:02:17.719
让我们暂且切换回 master 分支并进行提交

00:02:17.719 --> 00:02:20.879
这里的 master 一词表示分支的末端

00:02:20.879 --> 00:02:24.254
但这个最近的提交与过去的提交相连

00:02:24.254 --> 00:02:28.229
红线表示 master 分支中的所有提交

00:02:28.229 --> 00:02:32.519
所以提交 7 和 b 不包括在 master 分支中

00:02:32.520 --> 00:02:36.870
而且提交 f 和 4 也不在 master 分支中

00:02:36.870 --> 00:02:39.015
所以 如果我们现在打开代码编辑器

00:02:39.014 --> 00:02:42.824
我们对提交 f、4、7 和 b 所作的更改

00:02:42.824 --> 00:02:45.704
将不会出现在任何文件中

00:02:45.705 --> 00:02:49.490
因为 git 仅显示了 master 分支中的更改

00:02:49.490 --> 00:02:52.754
但不用担心 这些提交都被安全地保存在仓库中

00:02:52.754 --> 00:02:54.585
要将这些提交从仓库中调出

00:02:54.585 --> 00:02:58.150
只需切换到我们想要查找的提交所在的分支即可

00:02:58.150 --> 00:03:01.425
例如 如果我们切换到 header-fix 分支

00:03:01.425 --> 00:03:04.410
该分支所包含的提交就会

00:03:04.409 --> 00:03:08.000
出现在计算机的文件系统和代码编辑器中

